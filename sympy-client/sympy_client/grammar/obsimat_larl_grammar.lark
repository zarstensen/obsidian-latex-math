// Terminals are largely based on sympy's original latex.lark: https://github.com/sympy/sympy/blob/2e7baea39cd0d891433bdc2ef2222e445c381ca3/sympy/parsing/latex/lark/grammar/latex.lark
// grammar has been written from the ground up to support the faster lalr parser instead of earley.

// ======== Core structure ========

latex_string: expression

// an expression is a sum of terms
expression: term? ((ADD|SUB) term)*

// a term is a series of products of factors separated by product operators.
term: implicit_multiplication ((OPERATOR_MUL|OPERATOR_DIV) (ADD|SUB)? implicit_multiplication)*
// factors with no operator between them are implicitly multiplied together.
?implicit_multiplication: _factor+

// a factor is either a number, a constant, a symbol, or a function.
// here exponentiation, fractions, binomials are loosly seen as functions.
_factor: _factor_no_unit
    | unit
 
 _factor_no_unit: exponentiation
    | _base_factor

// _base_factor groups all factors which can be the base value of an exponentiation.
_base_factor: parenthesees_expression
    | braces_expression
    | _function
    | _number
    | symbol

// groups a base factor and an exponent factor to be evaluated in an exponentation.
exponentiation: _base_factor _CARET function_special_arg

// various rules for grouping expressions surrounded by delimiters.
?parenthesees_expression: _L_PAREN expression _R_PAREN
?braces_expression: _L_BRACE expression _R_BRACE
?brackets_expression: _L_BRACKET expression _R_BRACKET

// ======== Symbols ========

symbol: indexed_symbol | _non_indexed_symbol

single_letter_symbol: SINGLE_LETTER_SYMBOL -> symbol

// a formatted symbol is any symbol surrounded with a latex command which changes it visually.
// this could for example be \mathit
formatted_symbol: (CMD_MATH|CMD_BOLD_FORMAT) brace_surrounded_text [PRIMES]
_non_indexed_symbol: single_letter_symbol | MULTI_LETTER_SYMBOL | formatted_symbol

indexed_symbol: _non_indexed_symbol _UNDERSCORE (single_letter_symbol | _digit | brace_surrounded_text) [PRIMES]

// all the rules here should return the NAME (as in a str) of the symbol to be created
// the symbol rule is responsible for eactually creating the symbol and optionally substituting its value.

// this rule optionally tries to create a unit, instead of a symbol, if bunits are used.
// otherwise this is the same as the symbol rule.
unit: _L_BRACE _non_indexed_symbol _R_BRACE

_symbol_like: symbol | unit

// ======== Numbers ========

// groups any value which evaluates to a number.
_number: _numeric_number | _digit
// groups any value which evaluates to a number, and can be passed as an argument, without surrounding it with braces.
// it may be a bit counter intuitive, but here pi (and other constants) are essentially seen as a "_digit".
_digit: _numeric_digit | _constant

_constant: CONST_PI | CONST_EULER | CONST_IMAGINARY | CONST_INFINITY

_numeric_digit: NUMERIC_DIGIT
_numeric_number: NUMERIC_NUMBER

// ======== Functions ========

undefined_function: UNDEFINED_FUNC_START expression _R_PAREN

_function: _delimited_function
    | _named_function
    | _series_function
    | integral
    | sqrt
    | conjugate
    | frac
    | binom
    | factorial
    | derivative

_named_function: undefined_function | trig_function | _log | exponential | limit | _filter_functions

// this rule matches a singular argument to a function.
// if a function takes multiple non special arguments, _multiarg_func_arg should be used instead.
 // parenthesees_expression should maybe not be here. it does not render properly in all cases, but it is very convenient...

// matches a special kind of argument, defined by the fact that fractions and binomials can be passed without surrounding them with braces.
?function_special_arg: braces_expression | parenthesees_expression | _named_function | _delimited_function | frac | binom | single_letter_symbol | _digit


// named functions

_func_template{func_name}: func_name [_CARET function_special_arg] _factor_no_unit

// trigonometric functions

trig_function: _func_template{FUNC_SIN}
    | _func_template{FUNC_COS}
    | _func_template{FUNC_TAN}
    | _func_template{FUNC_CSC}
    | _func_template{FUNC_SEC}
    | _func_template{FUNC_COT}
    | _func_template{FUNC_ARCSIN}
    | _func_template{FUNC_ARCCOS}
    | _func_template{FUNC_ARCTAN}
    | _func_template{FUNC_ARCCSC}
    | _func_template{FUNC_ARCSEC}
    | _func_template{FUNC_ARCCOT}
    | _func_template{FUNC_SINH}
    | _func_template{FUNC_COSH}
    | _func_template{FUNC_TANH}
    | _func_template{FUNC_ARSINH}
    | _func_template{FUNC_ARCOSH}
    | _func_template{FUNC_ARTANH}

_log: log_implicit_base
    | log_explicit_base

log_implicit_base: _func_template{FUNC_LOG}
    | _func_template{FUNC_LN}
    | _func_template{FUNC_LG}
 
 // TODO: both orderings should be allowed, where caret is also to the left of the log.
log_explicit_base: FUNC_LOG _UNDERSCORE function_special_arg [_CARET function_special_arg] _factor_no_unit
    | FUNC_LOG _CARET function_special_arg _UNDERSCORE function_special_arg _factor_no_unit -> log_explicit_base_exponent_first

exponential: _func_template{_FUNC_EXP}

factorial: _factor_no_unit _BANG

sign: _L_BRACE (ADD|SUB) _R_BRACE
    | ADD
    | SUB

limit: _FUNC_LIMIT _UNDERSCORE _L_BRACE symbol _LIM_APPROACH_SYMBOL _base_factor [_CARET sign] _R_BRACE _factor_no_unit

_SERIES_ASSIGN_OPERATOR: EQUAL

_series_template_start_iter_first{series_name}: series_name _UNDERSCORE _L_BRACE symbol _SERIES_ASSIGN_OPERATOR expression _R_BRACE _CARET function_special_arg _factor_no_unit
_series_template_end_iter_first{series_name}: series_name _CARET function_special_arg _UNDERSCORE _L_BRACE symbol _SERIES_ASSIGN_OPERATOR expression _R_BRACE _factor_no_unit

_series_function: sum | product

sum: _series_template_start_iter_first{_FUNC_SUM} -> sum_start_iter_first
    | _series_template_end_iter_first{_FUNC_SUM} -> sum_end_iter_first


product: _series_template_start_iter_first{_FUNC_PRODUCT} -> product_start_iter_first
    | _series_template_end_iter_first{_FUNC_PRODUCT} -> product_end_iter_first
    
// filter functions

_filter_functions: min | max

list_of_expressions: expression (_COMMA expression)*

min: _FUNC_MIN _L_PAREN list_of_expressions _R_PAREN
max: _FUNC_MAX _L_PAREN list_of_expressions _R_PAREN

// delimited functions
_delimited_function: abs | norm | inner_product | floor | ceil
_inner_product_separator: _L_BAR | _COMMA
inner_product: _CMD_LANGLE expression _inner_product_separator expression _CMD_RANGLE
abs: _L_BAR expression _R_BAR
norm: _L_DOUBLE_BAR expression _R_DOUBLE_BAR
floor: _L_FLOOR expression _R_FLOOR
ceil: _L_CEIL expression _R_CEIL
sqrt: _FUNC_SQRT [brackets_expression] (braces_expression|single_letter_symbol|_digit)
conjugate: _FUNC_CONJUGATE (braces_expression|single_letter_symbol|_digit)

// TODO: wait for matrix implementation.
// determinant: _func_template{FUNC_DETERMINANT}
// trace: _func_template{FUNC_MATRIX_TRACE}
// adjungate: _func_template{FUNC_MATRIX_ADJUGATE}

// match a single argument in a list of arguments latex style (that is \command{arg1}{arg2}...{argN})
_multiarg_func_arg: (braces_expression|single_letter_symbol|_digit)
// terminal signifying the end of a single argument in a latex style argument list.
// due to lalr's limited lookahead, a custom post lexer needs to insert this token when parsing.
// this also requires a bit more setup in the grammar for this to work, which is specified in the following comment.
//
// this token should be placed between _multiarg_func_arg rules when specifying the list of arguments.
// additionally, there must be a terminal before the first _multiarg_func_arg rule, which follows the following naming convention:
// MULTIARG_FUNC_[num_args][terminal_name]
// num_args: number of arguments this function takes. This must be number of MULTIARG_FUNC_ARG_DELIMITER occurenses + 1
// terminal_name: this is ignored by the postlexer and can be used to name the terminal appropiately.
%declare _MULTIARG_DELIMITER
%declare _MULTIARG_EOS

// core functions
frac: _FUNC_FRAC _multiarg_func_arg _MULTIARG_DELIMITER _multiarg_func_arg _MULTIARG_EOS
binom: _FUNC_BINOM _multiarg_func_arg _MULTIARG_DELIMITER _multiarg_func_arg _MULTIARG_EOS

diff_symbol_exponent: symbol [_CARET function_special_arg]
diff_symbol_arg_list: (_DIFFERENTIAL_SYMBOL diff_symbol_exponent)+

// need to have a post lex which recognises _FUNC_DERIVATIVE and then replaces any single letter symbol which matches _DIFFERENTIAL_SYMBOL with _DIFFERENTIAL_SYMBOL
derivative: _FUNC_DERIVATIVE expression _R_BRACE _L_BRACE diff_symbol_arg_list _R_BRACE -> derivative_func_first
    |   _FUNC_DERIVATIVE _R_BRACE _L_BRACE diff_symbol_arg_list _R_BRACE _factor_no_unit -> derivative_symbols_first

// DIFFERENTIAL_SYMBOl should be outputted by the post lexer.
// it should probably be restructured a bit before this though.
integral: _FUNC_INTEGRAL [expression] _DIFFERENTIAL_SYMBOL symbol -> integral_no_bounds
    | _FUNC_INTEGRAL _UNDERSCORE function_special_arg _CARET function_special_arg [expression] _DIFFERENTIAL_SYMBOL symbol -> integral_lower_bound_first
    | _FUNC_INTEGRAL _CARET function_special_arg _UNDERSCORE function_special_arg [expression] _DIFFERENTIAL_SYMBOL symbol -> integral_upper_bound_first

// ======== Miscellaneous rules ========

!brace_surrounded_text: _L_BRACE /[^{}]+/ (brace_surrounded_text /[^{}]+/?)?  _R_BRACE

// ================ Terminals ================

// ignore escaped whitespace in latex code
%ignore /(?<!\\)\\ /

%ignore /[ \t\n\r]+/

%ignore "\\," | "\\thinspace" | "\\:" | "\\medspace" | "\\;" | "\\thickspace"
%ignore "\\quad" | "\\qquad"
%ignore "\\!" | "\\negthinspace" | "\\negmedspace" | "\\negthickspace"
%ignore "\\vrule" | "\\vcenter" | "\\vbox" | "\\vskip" | "\\vspace" | "\\hfill"
%ignore "\\*" | "\\-" | "\\." | "\\/" | "\\(" | "\\=" | "\\middle"

%ignore "\\left" | "\\right"
%ignore "\\limits" | "\\nolimits"
%ignore "\\displaystyle"

// basic binary operators
ADD: "+"
SUB: "-"
MUL: "*"
DIV: "/" | "\\over"

// basic common operators
_CMD_TIMES: "\\times"
_CMD_CDOT:  "\\cdot"
_CMD_DIV:   "\\div"
_CMD_BAR: "\\bar"
_CMD_OVERLINE: "\\overline"
_CMD_LANGLE: "\\langle" | "<"
_CMD_RANGLE: "\\rangle" | ">"
_CMD_INNER_PRODUCT_SEPARATOR: _BAR | _COMMA

// tokens with distinct left and right symbols
_L_BRACE: "{"
_R_BRACE: "}"
L_BRACE_LITERAL: "\\{"
R_BRACE_LITERAL: "\\}"
_L_BRACKET: "["
_R_BRACKET: "]"
_L_CEIL: "\\lceil"
_R_CEIL: "\\rceil"
_L_FLOOR: "\\lfloor"
_R_FLOOR: "\\rfloor"
_L_PAREN: "("
_R_PAREN: ")"
_L_BAR: _BAR
%declare _R_BAR
_L_DOUBLE_BAR: _DOUBLE_BAR
%declare _R_DOUBLE_BAR

// limit, integral, sum, and product symbols
_FUNC_LIMIT:  "\\lim"
_LIM_APPROACH_SYMBOL: "\\to" | "\\rightarrow" | "\\Rightarrow" | "\\longrightarrow" | "\\Longrightarrow"
_FUNC_INTEGRAL:  "\\int" | "\\intop"
_FUNC_SUM:  "\\sum"
_FUNC_PRODUCT: "\\prod"

// common functions
_FUNC_EXP:  "\\exp"
FUNC_LOG:  "\\log"
FUNC_LN:   "\\ln"
FUNC_LG:   "\\lg"
_FUNC_MIN: "\\min"
_FUNC_MAX: "\\max"
_FUNC_CONJUGATE: _CMD_OVERLINE | _CMD_BAR

// multiarg functions

_FUNC_FRAC: /\\[dtcs]?frac/ | "\\nicefrac"
_FUNC_BINOM: /\\[dt]?binom/

_FUNC_DERIVATIVE: _FUNC_FRAC _WS? _L_BRACE _WS? _DIFFERENTIAL_SYMBOL

_FUNC_OVERLINE: "\\overline"

// trigonometric functions
FUNC_SIN:  "\\sin"
FUNC_COS:  "\\cos"
FUNC_TAN:  "\\tan"
FUNC_CSC:  "\\csc"
FUNC_SEC:  "\\sec"
FUNC_COT:  "\\cot"

// inverse trigonometric functions
FUNC_ARCSIN: "\\arcsin"
FUNC_ARCCOS: "\\arccos"
FUNC_ARCTAN: "\\arctan"
FUNC_ARCCSC: "\\arccsc"
FUNC_ARCSEC: "\\arcsec"
FUNC_ARCCOT: "\\arccot"

// hyperbolic trigonometric functions
FUNC_SINH: "\\sinh"
FUNC_COSH: "\\cosh"
FUNC_TANH: "\\tanh"
FUNC_ARSINH: "\\arsinh"
FUNC_ARCOSH: "\\arcosh"
FUNC_ARTANH: "\\artanh"

_FUNC_SQRT: "\\sqrt"

UNDEFINED_FUNC_START: SINGLE_LETTER_SYMBOL _L_PAREN | MULTI_LETTER_SYMBOL _L_PAREN

// mathematical constants
CONST_PI: "\\pi"
CONST_EULER: "e"
CONST_IMAGINARY: "i"
CONST_INFINITY: "\\infty"

CMD_MATH: /\\math\w+/
CMD_BOLD_FORMAT: "\\pmb"

CMD_FORMAT: CMD_MATH | CMD_BOLD_FORMAT

_BANG: "!"
_BAR: "|" | "\\mid"
_DOUBLE_BAR: "||" | /\\mid\s*\\mid/ | "\\Vert"
_DOT: "."
_CARET: "^"
_COLON: ":"
_COMMA: ","
_UNDERSCORE: "_"

// relational symbols
EQUAL: "="
NOT_EQUAL: "\\neq" | "\\ne"
LT: "<"
LTE: "\\leq" | "\\le" | "\\leqslant"
GT: ">"
GTE: "\\geq" | "\\ge" | "\\geqslant"

OPERATOR_DIV: _CMD_DIV | DIV
OPERATOR_MUL: MUL | _CMD_TIMES | _CMD_CDOT

%import .greek_symbols.GREEK_SYMBOL

_DELTA_DIFFERENTIAL_SYMBOL: "\\delta"
_UPRIGHT_DIFFERENTIAL_SYMBOL: "\\text{d}" | "\\mathrm{d}"
_DIFFERENTIAL_SYMBOL.2: "d" | _UPRIGHT_DIFFERENTIAL_SYMBOL | _DELTA_DIFFERENTIAL_SYMBOL

%import common.WS -> _WS

// should this just be \w?
LATIN_SYMBOL: /[a-zA-Z]/
LATIN_SYMBOL_WITH_PRIMTES: LATIN_SYMBOL PRIMES
MULTI_LETTER_LATIN_SYMBOL: /[a-zA-Z]{2,}'*/
GREEK_SYMBOL_WITH_PRIMES: GREEK_SYMBOL PRIMES

SINGLE_LETTER_SYMBOL: LATIN_SYMBOL | GREEK_SYMBOL

MULTI_LETTER_SYMBOL: LATIN_SYMBOL_WITH_PRIMTES | GREEK_SYMBOL_WITH_PRIMES | MULTI_LETTER_LATIN_SYMBOL

%import common.DIGIT -> NUMERIC_DIGIT

NUMERIC_NUMBER: NUMERIC_DIGIT NUMERIC_DIGIT+ | NUMERIC_DIGIT* _DOT NUMERIC_DIGIT+

CMD_PRIME: "\\prime"
CMD_ASTERISK: "\\ast"

PRIMES: "'"+
STARS: "*"+
PRIMES_VIA_CMD: CMD_PRIME+
STARS_VIA_CMD: CMD_ASTERISK+

CMD_BEGIN: "\\begin"
CMD_END: "\\end"

// matrices
// IGNORE_L: /[ \t\n\r]*/ L_BRACE* /[ \t\n\r]*/
// IGNORE_R: /[ \t\n\r]*/ R_BRACE* /[ \t\n\r]*/
// ARRAY_MATRIX_BEGIN: L_BRACE "array" R_BRACE L_BRACE /[^}]*/ R_BRACE
// ARRAY_MATRIX_END: L_BRACE "array" R_BRACE
// AMSMATH_MATRIX: L_BRACE "matrix" R_BRACE
// AMSMATH_PMATRIX: L_BRACE "pmatrix" R_BRACE
// AMSMATH_BMATRIX: L_BRACE "bmatrix" R_BRACE
// // Without the (L|R)_PARENs and (L|R)_BRACKETs, a matrix defined using
// // \begin{array}...\end{array} or \begin{matrix}...\end{matrix} must
// // not qualify as a complete matrix expression; this is done so that
// // if we have \begin{array}...\end{array} or \begin{matrix}...\end{matrix}
// // between BAR pairs, then they should be interpreted as determinants as
// // opposed to sympy.Abs (absolute value) applied to a matrix.
// CMD_BEGIN_AMSPMATRIX_AMSBMATRIX: CMD_BEGIN (AMSMATH_PMATRIX | AMSMATH_BMATRIX)
// CMD_BEGIN_ARRAY_AMSMATRIX: (L_PAREN | L_BRACKET) IGNORE_L CMD_BEGIN (ARRAY_MATRIX_BEGIN | AMSMATH_MATRIX)
// CMD_MATRIX_BEGIN: CMD_BEGIN_AMSPMATRIX_AMSBMATRIX | CMD_BEGIN_ARRAY_AMSMATRIX
// CMD_END_AMSPMATRIX_AMSBMATRIX: CMD_END (AMSMATH_PMATRIX | AMSMATH_BMATRIX)
// CMD_END_ARRAY_AMSMATRIX: CMD_END (ARRAY_MATRIX_END | AMSMATH_MATRIX) IGNORE_R "\\right"? (R_PAREN | R_BRACKET)
// CMD_MATRIX_END: CMD_END_AMSPMATRIX_AMSBMATRIX | CMD_END_ARRAY_AMSMATRIX
// MATRIX_COL_DELIM: "&"
// MATRIX_ROW_DELIM: "\\\\"
// FUNC_MATRIX_TRACE: "\\trace"
// FUNC_MATRIX_ADJUGATE: "\\adjugate"

// // determinants
// AMSMATH_VMATRIX: L_BRACE "vmatrix" R_BRACE
// CMD_DETERMINANT_BEGIN_SIMPLE: CMD_BEGIN AMSMATH_VMATRIX
// CMD_DETERMINANT_BEGIN_VARIANT: BAR IGNORE_L CMD_BEGIN (ARRAY_MATRIX_BEGIN | AMSMATH_MATRIX)
// CMD_DETERMINANT_BEGIN: CMD_DETERMINANT_BEGIN_SIMPLE | CMD_DETERMINANT_BEGIN_VARIANT
// CMD_DETERMINANT_END_SIMPLE: CMD_END AMSMATH_VMATRIX
// CMD_DETERMINANT_END_VARIANT: CMD_END (ARRAY_MATRIX_END | AMSMATH_MATRIX) IGNORE_R "\\right"? BAR
// CMD_DETERMINANT_END: CMD_DETERMINANT_END_SIMPLE | CMD_DETERMINANT_END_VARIANT
// FUNC_DETERMINANT: "\\det"
