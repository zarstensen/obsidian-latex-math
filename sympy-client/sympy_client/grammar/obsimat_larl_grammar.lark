// Terminals are largely based on sympy's original latex.lark: https://github.com/sympy/sympy/blob/2e7baea39cd0d891433bdc2ef2222e445c381ca3/sympy/parsing/latex/lark/grammar/latex.lark
// grammar has been written from the ground up to support the faster lalr parser instead of earley.

// ======== Core structure ========

latex_string: relation

_rel_op: EQUAL | NOT_EQUAL | LT | LTE | GT | GTE
relation: _rel_op? expression (_rel_op expression)* _rel_op?

// an expression is a sum of terms
expression: term ((ADD|SUB) term)*
    | ((ADD|SUB) term)+

// a term is a series of products of factors separated by product operators.
term: implicit_multiplication ((OPERATOR_MUL|OPERATOR_DIV) (ADD|SUB)? implicit_multiplication)*
// factors with no operator between them are implicitly multiplied together.
?implicit_multiplication: _factor+

// a factor is either a number, a constant, a symbol, or a function.
// here exponentiation, fractions, binomials are loosly seen as functions.
_factor: _factor_no_unit
    | unit
 
 _factor_no_unit: exponentiation
    | _base_factor

_base_factor: parenthesees_expression
    | braces_expression
    | _function
    | _number
    | symbol
    | _matrix_notation

// _base_factor groups all factors which can be the base value of an exponentiation.
// _base_factor_no_matrix: 

// groups a base factor and an exponent factor to be evaluated in an exponentation.
exponentiation: _base_factor _CARET function_special_arg
    | _base_factor _CARET (ADJOINT_TRANSPOSE_EXPONENT|ADJOINT_TRANSPOSE_EXPONENTS) -> exp_transpose
    | _base_factor PRIMES -> exp_transpose

// various rules for grouping expressions surrounded by delimiters.
?parenthesees_expression: _L_PAREN expression _R_PAREN
?braces_expression: _L_BRACE expression _R_BRACE
?brackets_expression: _L_BRACKET expression _R_BRACKET

// ======== Symbols ========

symbol: indexed_symbol | _non_indexed_symbol

single_letter_symbol: SINGLE_LETTER_SYMBOL -> symbol

// a formatted symbol is any symbol surrounded with a latex command which changes it visually.
// this could for example be \mathit
formatted_symbol: (CMD_MATH|CMD_BOLD_FORMAT) brace_surrounded_text [PRIMES]
_non_indexed_symbol: single_letter_symbol | MULTI_LETTER_SYMBOL | formatted_symbol

indexed_symbol: _non_indexed_symbol _UNDERSCORE (single_letter_symbol | _digit | brace_surrounded_text) [PRIMES]

// all the rules here should return the NAME (as in a str) of the symbol to be created
// the symbol rule is responsible for eactually creating the symbol and optionally substituting its value.

// this rule optionally tries to create a unit, instead of a symbol, if bunits are used.
// otherwise this is the same as the symbol rule.
unit: _L_BRACE _non_indexed_symbol _R_BRACE

_symbol_like: symbol | unit

// ======== Numbers ========

// groups any value which evaluates to a number.
_number: _numeric_number | _digit
// groups any value which evaluates to a number, and can be passed as an argument, without surrounding it with braces.
// it may be a bit counter intuitive, but here pi (and other constants) are essentially seen as a "_digit".
_digit: _numeric_digit | _constant

_constant: CONST_PI | CONST_EULER | CONST_IMAGINARY | CONST_INFINITY

_numeric_digit: NUMERIC_DIGIT
_numeric_number: NUMERIC_NUMBER

// ======== Functions ========

undefined_function: UNDEFINED_FUNC_START list_of_expressions _R_PAREN

_function: _delimited_function
    | _named_function
    | _series_function
    | integral
    | sqrt
    | conjugate
    | frac
    | binom
    | factorial
    | derivative

_named_function: undefined_function | trig_function | _log | exponential | limit | _filter_functions | _matrix_functions

// this rule matches a singular argument to a function.
// if a function takes multiple non special arguments, _multiarg_func_arg should be used instead.
 // parenthesees_expression should maybe not be here. it does not render properly in all cases, but it is very convenient...

// matches a special kind of argument, defined by the fact that fractions and binomials can be passed without surrounding them with braces.
?function_special_arg: braces_expression | parenthesees_expression | _named_function | _delimited_function | frac | binom | single_letter_symbol | _digit


// named functions

_func_template{func_name}: func_name [_CARET function_special_arg] _factor_no_unit

// trigonometric functions

trig_function: _func_template{FUNC_SIN}
    | _func_template{FUNC_COS}
    | _func_template{FUNC_TAN}
    | _func_template{FUNC_CSC}
    | _func_template{FUNC_SEC}
    | _func_template{FUNC_COT}
    | _func_template{FUNC_ARCSIN}
    | _func_template{FUNC_ARCCOS}
    | _func_template{FUNC_ARCTAN}
    | _func_template{FUNC_ARCCSC}
    | _func_template{FUNC_ARCSEC}
    | _func_template{FUNC_ARCCOT}
    | _func_template{FUNC_SINH}
    | _func_template{FUNC_COSH}
    | _func_template{FUNC_TANH}
    | _func_template{FUNC_ARSINH}
    | _func_template{FUNC_ARCOSH}
    | _func_template{FUNC_ARTANH}

_log: log_implicit_base
    | log_explicit_base

log_implicit_base: _func_template{FUNC_LOG}
    | _func_template{FUNC_LN}
    | _func_template{FUNC_LG}
 
 // TODO: both orderings should be allowed, where caret is also to the left of the log.
log_explicit_base: FUNC_LOG _UNDERSCORE function_special_arg [_CARET function_special_arg] _factor_no_unit
    | FUNC_LOG _CARET function_special_arg _UNDERSCORE function_special_arg _factor_no_unit -> log_explicit_base_exponent_first

exponential: _func_template{_FUNC_EXP}

factorial: _factor_no_unit _BANG

derivative_prime: _factor_no_unit PRIMES

sign: _L_BRACE (ADD|SUB) _R_BRACE
    | ADD
    | SUB

limit: _FUNC_LIMIT _UNDERSCORE _L_BRACE symbol _LIM_APPROACH_SYMBOL _base_factor [_CARET sign] _R_BRACE _factor_no_unit

_series_template_start_iter_first{series_name}: series_name _UNDERSCORE _L_BRACE symbol EQUAL expression _R_BRACE _CARET function_special_arg _factor_no_unit
_series_template_end_iter_first{series_name}: series_name _CARET function_special_arg _UNDERSCORE _L_BRACE symbol EQUAL expression _R_BRACE _factor_no_unit

_series_function: sum | product

sum: _series_template_start_iter_first{_FUNC_SUM} -> sum_start_iter_first
    | _series_template_end_iter_first{_FUNC_SUM} -> sum_end_iter_first


product: _series_template_start_iter_first{_FUNC_PRODUCT} -> product_start_iter_first
    | _series_template_end_iter_first{_FUNC_PRODUCT} -> product_end_iter_first
    
// filter functions

_filter_functions: min | max

list_of_expressions: expression (_COMMA expression)*

min: _FUNC_MIN _L_PAREN list_of_expressions _R_PAREN
max: _FUNC_MAX _L_PAREN list_of_expressions _R_PAREN

// delimited functions
_delimited_function: abs | norm | inner_product | floor | ceil

%declare _INNER_PRODUCT_SEPARATOR
inner_product: _L_ANGLE expression _INNER_PRODUCT_SEPARATOR expression _R_ANGLE
abs: _L_BAR expression _R_BAR
norm: _L_DOUBLE_BAR expression _R_DOUBLE_BAR
floor: _L_FLOOR expression _R_FLOOR
ceil: _L_CEIL expression _R_CEIL
sqrt: _FUNC_SQRT [brackets_expression] (braces_expression|single_letter_symbol|_digit)
conjugate: _FUNC_CONJUGATE (braces_expression|single_letter_symbol|_digit)

// match a single argument in a list of arguments latex style (that is \command{arg1}{arg2}...{argN})
_multiarg_func_arg: (braces_expression|single_letter_symbol|_digit)
// terminal signifying the end of a single argument in a latex style argument list.
// due to lalr's limited lookahead, a custom post lexer needs to insert this token when parsing.
// this also requires a bit more setup in the grammar for this to work, which is specified in the following comment.
//
// this token should be placed between _multiarg_func_arg rules when specifying the list of arguments.
// additionally, there must be a terminal before the first _multiarg_func_arg rule, which follows the following naming convention:
// MULTIARG_FUNC_[num_args][terminal_name]
// num_args: number of arguments this function takes. This must be number of MULTIARG_FUNC_ARG_DELIMITER occurenses + 1
// terminal_name: this is ignored by the postlexer and can be used to name the terminal appropiately.
%declare _MULTIARG_DELIMITER
%declare _MULTIARG_EOS

// core functions
frac: _FUNC_FRAC _multiarg_func_arg _MULTIARG_DELIMITER _multiarg_func_arg _MULTIARG_EOS
binom: _FUNC_BINOM _multiarg_func_arg _MULTIARG_DELIMITER _multiarg_func_arg _MULTIARG_EOS

diff_symbol_exponent: symbol [_CARET function_special_arg]
diff_symbol_arg_list: (_DIFFERENTIAL_SYMBOL diff_symbol_exponent)+

// need to have a post lex which recognises _FUNC_DERIVATIVE and then replaces any single letter symbol which matches _DIFFERENTIAL_SYMBOL with _DIFFERENTIAL_SYMBOL
derivative: _FUNC_DERIVATIVE expression _R_BRACE _L_BRACE diff_symbol_arg_list _R_BRACE -> derivative_func_first
    |   _FUNC_DERIVATIVE _R_BRACE _L_BRACE diff_symbol_arg_list _R_BRACE _factor_no_unit -> derivative_symbols_first

integral: _FUNC_INTEGRAL [expression] _DIFFERENTIAL_SYMBOL symbol -> integral_no_bounds
    | _FUNC_INTEGRAL _UNDERSCORE function_special_arg _CARET function_special_arg [expression] _DIFFERENTIAL_SYMBOL symbol -> integral_lower_bound_first
    | _FUNC_INTEGRAL _CARET function_special_arg _UNDERSCORE function_special_arg [expression] _DIFFERENTIAL_SYMBOL symbol -> integral_upper_bound_first

// ======== Matrices ========

// det_matrix is differentiated from the other matrices, as this one evaluates to the determinant value, which is a scalar and not a matrix.
// TODO: different name for these?
_matrix_notation: _matrix_type | det_matrix
_matrix_type: matrix | array_matrix

matrix_body: expression ((_MATRIX_COL_DELIM|MATRIX_ROW_DELIM) expression)*
matrix: CMD_BEGIN_MATRIX matrix_body CMD_END_MATRIX _MATRIX_ENV_END
array_matrix: CMD_BEGIN_ARRAY ARRAY_ENV_OPTIONS matrix_body CMD_END_ARRAY _MATRIX_ENV_END
det_matrix: CMD_BEGIN_VMATRIX matrix_body CMD_END_VMATRIX _MATRIX_ENV_END

// ======== Matrices functions ========

_matrix_functions: determinant | trace | adjugate | rref | gradient | hessian | jacobian | rref

determinant: _func_template{_FUNC_MATRIX_DETERMINANT}
trace: _func_template{_FUNC_MATRIX_TRACE}
adjugate: _func_template{_FUNC_MATRIX_ADJUGATE}
rref: _func_template{_FUNC_MATRIX_RREF}

gradient: _func_template{_FUNC_GRADIENT}
hessian: _func_template{_FUNC_HESSIAN}
jacobian: _func_template{_FUNC_JACOBIAN}

// ======== Miscellaneous rules ========

// TODO: i dont see a reason why this priority should change anything, but it does so its here now.
NON_BRACE_TEXT.-1: /[^{}]+/
!brace_surrounded_text: _L_BRACE NON_BRACE_TEXT? (brace_surrounded_text NON_BRACE_TEXT?)*  _R_BRACE

// ================ Terminals ================

// ignore escaped whitespace in latex code
%ignore /(?<!\\)\\ /

%ignore _WS

%ignore "\\," | "\\thinspace" | "\\:" | "\\medspace" | "\\;" | "\\thickspace"
%ignore "\\quad" | "\\qquad"
%ignore "\\!" | "\\negthinspace" | "\\negmedspace" | "\\negthickspace"
%ignore "\\vrule" | "\\vcenter" | "\\vbox" | "\\vskip" | "\\vspace" | "\\hfill"
%ignore "\\*" | "\\-" | "\\." | "\\/" | "\\(" | "\\=" | "\\middle"

%ignore "\\left" | "\\right"
%ignore "\\limits" | "\\nolimits"
%ignore "\\displaystyle"

// basic binary operators
ADD: "+"
SUB: "-"
MUL: "*"
DIV: "/" | "\\over"

// basic common operators
_CMD_TIMES: "\\times"
_CMD_CDOT:  "\\cdot"
_CMD_DIV:   "\\div"
_CMD_BAR: "\\bar"
_CMD_OVERLINE: "\\overline"
_CMD_INNER_PRODUCT_SEPARATOR: _BAR | _COMMA

// tokens with distinct left and right symbols
_L_ANGLE: "\\langle" | "<"
_R_ANGLE: "\\rangle" | ">"
_L_BRACE: "{"
_R_BRACE: "}"
L_BRACE_LITERAL: "\\{"
R_BRACE_LITERAL: "\\}"
_L_BRACKET: "["
_R_BRACKET: "]"
_L_CEIL: "\\lceil"
_R_CEIL: "\\rceil"
_L_FLOOR: "\\lfloor"
_R_FLOOR: "\\rfloor"
_L_PAREN: "("
_R_PAREN: ")"
_L_BAR: _BAR
%declare _R_BAR
_L_DOUBLE_BAR: _DOUBLE_BAR
%declare _R_DOUBLE_BAR

_L_DELIMITER: _L_ANGLE | L_BRACE_LITERAL | _L_BRACKET | _L_CEIL | _L_FLOOR | _L_PAREN
_R_DELIMITER: _R_ANGLE | R_BRACE_LITERAL | _R_BRACKET | _R_CEIL | _R_FLOOR | _R_PAREN

// limit, integral, sum, and product symbols
_FUNC_LIMIT:  "\\lim"
_LIM_APPROACH_SYMBOL: "\\to" | "\\rightarrow" | "\\Rightarrow" | "\\longrightarrow" | "\\Longrightarrow"
_FUNC_INTEGRAL:  "\\int" | "\\intop"
_FUNC_SUM:  "\\sum"
_FUNC_PRODUCT: "\\prod"

// common functions
_FUNC_EXP:  "\\exp"
FUNC_LOG:  "\\log"
FUNC_LN:   "\\ln"
FUNC_LG:   "\\lg"
_FUNC_MIN: "\\min"
_FUNC_MAX: "\\max"
_FUNC_CONJUGATE: _CMD_OVERLINE | _CMD_BAR

// multiarg functions

_FUNC_FRAC: /\\[dtcs]?frac/ | "\\nicefrac"
_FUNC_BINOM: /\\[dt]?binom/

_FUNC_DERIVATIVE: _FUNC_FRAC _WS? _L_BRACE _WS? _DIFFERENTIAL_SYMBOL

_FUNC_OVERLINE: "\\overline"

// trigonometric functions
FUNC_SIN:  "\\sin"
FUNC_COS:  "\\cos"
FUNC_TAN:  "\\tan"
FUNC_CSC:  "\\csc"
FUNC_SEC:  "\\sec"
FUNC_COT:  "\\cot"

// inverse trigonometric functions
FUNC_ARCSIN: "\\arcsin"
FUNC_ARCCOS: "\\arccos"
FUNC_ARCTAN: "\\arctan"
FUNC_ARCCSC: "\\arccsc"
FUNC_ARCSEC: "\\arcsec"
FUNC_ARCCOT: "\\arccot"

// hyperbolic trigonometric functions
FUNC_SINH: "\\sinh"
FUNC_COSH: "\\cosh"
FUNC_TANH: "\\tanh"
FUNC_ARSINH: "\\arsinh"
FUNC_ARCOSH: "\\arcosh"
FUNC_ARTANH: "\\artanh"

_FUNC_SQRT: "\\sqrt"

// matrix functions

_FUNC_MATRIX_DETERMINANT: "\\det"
_FUNC_MATRIX_TRACE: CMD_OPERATOR _WS? _L_BRACE _WS? "\\trace" _WS? _R_BRACE
_FUNC_MATRIX_ADJUGATE: CMD_OPERATOR _WS? _L_BRACE _WS? "\\adjugate" _WS? _R_BRACE
_FUNC_MATRIX_RREF: CMD_OPERATOR _WS? _L_BRACE _WS? "\\rref" _WS? _R_BRACE

// linear alg functions.

_FUNC_GRADIENT: "\\nabla"
_FUNC_HESSIAN: CMD_MATRIX_FORMAT _WS? _L_BRACE _WS? "H" _WS? _R_BRACE
_FUNC_JACOBIAN: CMD_MATRIX_FORMAT _WS? _L_BRACE _WS? "J" _WS? _R_BRACE

// TODO: use a bit more elaborate regex here, so more complex strings are allowed in the index.
UNDEFINED_FUNC_START: (SINGLE_LETTER_SYMBOL|MULTI_LETTER_SYMBOL) (_WS? _UNDERSCORE _WS? _L_BRACE /\s*[^{}]+\s*/ _R_BRACE)? _L_PAREN

// mathematical constants
CONST_PI: "\\pi"
CONST_EULER: "e"
CONST_IMAGINARY: "i"
CONST_INFINITY: "\\infty"

CMD_MATH: /\\math\w+/
CMD_BOLD_FORMAT: "\\pmb"

CMD_FORMAT: CMD_MATH | CMD_BOLD_FORMAT

// mathrm is also included here so operatorname does not have to be used everywhere.
CMD_OPERATOR: "\\operatorname" | "\\mathrm"
CMD_MATRIX_FORMAT: "\\mathbf"

_BANG: "!"
_BAR: "|" | "\\mid"
_DOUBLE_BAR: "||" | /\\mid\s*\\mid/ | "\\Vert"
_DOT: "."
_CARET: "^"
_COLON: ":"
_COMMA: ","
_UNDERSCORE: "_"

// relational symbols
EQUAL: "="
NOT_EQUAL: _BANG EQUAL | "\\neq" | "\\ne"
LT: "<"
LTE: LT EQUAL | "\\leq" | "\\leqslant" // | "\\le" removed because it collides with \\left
GT: ">"
GTE: GT EQUAL | "\\geq" | "\\ge" | "\\geqslant"

OPERATOR_DIV: _CMD_DIV | DIV
OPERATOR_MUL: MUL | _CMD_TIMES | _CMD_CDOT

%import .greek_symbols.GREEK_SYMBOL

_DELTA_DIFFERENTIAL_SYMBOL: "\\delta"
_UPRIGHT_DIFFERENTIAL_SYMBOL: "\\text{d}" | "\\mathrm{d}"
// TODO: this priority should ideally not be here.
_DIFFERENTIAL_SYMBOL.1: "d" | _UPRIGHT_DIFFERENTIAL_SYMBOL | _DELTA_DIFFERENTIAL_SYMBOL

_WS: /[\s\t\n\r]+/

// should this just be \w?
LATIN_SYMBOL: /[a-zA-Z]/
LATIN_SYMBOL_WITH_PRIMTES: LATIN_SYMBOL PRIMES
MULTI_LETTER_LATIN_SYMBOL: /[a-zA-Z]{2,}'*/
GREEK_SYMBOL_WITH_PRIMES: GREEK_SYMBOL PRIMES

SINGLE_LETTER_SYMBOL: LATIN_SYMBOL | GREEK_SYMBOL

MULTI_LETTER_SYMBOL: LATIN_SYMBOL_WITH_PRIMTES | GREEK_SYMBOL_WITH_PRIMES | MULTI_LETTER_LATIN_SYMBOL

%import common.DIGIT -> NUMERIC_DIGIT

NUMERIC_NUMBER: NUMERIC_DIGIT NUMERIC_DIGIT+ | NUMERIC_DIGIT* _DOT NUMERIC_DIGIT+

CMD_PRIME: "\\prime"
CMD_ASTERISK: "\\ast"

PRIMES: "'"+
STARS: "*"+
PRIMES_VIA_CMD: CMD_PRIME+
STARS_VIA_CMD: CMD_ASTERISK+

TRANSPOSE_EXPONENT: CMD_PRIME | "'"
ADJOINT_EXPONENT: CMD_ASTERISK | "*"

ADJOINT_TRANSPOSE_EXPONENT: /(\\prime|\\ast|'|\*)/
ADJOINT_TRANSPOSE_EXPONENTS: /{(\\prime|\\ast|'|\*|\s)+}/

CMD_BEGIN: "\\begin" _WS? _L_BRACE
// TODO: this is not going to be used?
CMD_END: "\\end" _WS? _L_BRACE

// matrices

ARRAY_ENV: "array"
MATRIX_ENV: /([bp]?(?:small)?)matrix/
VMATRIX_ENV: /v(small)?matrix/

%declare _MATRIX_ENV_END

CMD_BEGIN_MATRIX: CMD_BEGIN _WS? MATRIX_ENV _WS? _R_BRACE
CMD_END_MATRIX: CMD_END _WS? MATRIX_ENV _WS? _R_BRACE

CMD_BEGIN_VMATRIX: CMD_BEGIN _WS? VMATRIX_ENV _WS? _R_BRACE
CMD_END_VMATRIX: CMD_END _WS? VMATRIX_ENV _WS? _R_BRACE

CMD_BEGIN_ARRAY: ("\\left" _WS? _L_DELIMITER)? _WS? CMD_BEGIN _WS? ARRAY_ENV _WS? _R_BRACE
ARRAY_ENV_OPTIONS: _L_BRACE (/[clr|\s]+/)? _R_BRACE
CMD_END_ARRAY: CMD_END _WS? ARRAY_ENV _WS? _R_BRACE _WS? ("\\right" _WS? _R_DELIMITER)?

_MATRIX_COL_DELIM: "&"
MATRIX_ROW_DELIM: "\\\\"

// IGNORE_L: /[ \t\n\r]*/ L_BRACE* /[ \t\n\r]*/
// IGNORE_R: /[ \t\n\r]*/ R_BRACE* /[ \t\n\r]*/
// ARRAY_MATRIX_BEGIN: L_BRACE "array" R_BRACE L_BRACE /[^}]*/ R_BRACE
// ARRAY_MATRIX_END: L_BRACE "array" R_BRACE
// AMSMATH_MATRIX: L_BRACE "matrix" R_BRACE
// AMSMATH_PMATRIX: L_BRACE "pmatrix" R_BRACE
// AMSMATH_BMATRIX: L_BRACE "bmatrix" R_BRACE
// // Without the (L|R)_PARENs and (L|R)_BRACKETs, a matrix defined using
// // \begin{array}...\end{array} or \begin{matrix}...\end{matrix} must
// // not qualify as a complete matrix expression; this is done so that
// // if we have \begin{array}...\end{array} or \begin{matrix}...\end{matrix}
// // between BAR pairs, then they should be interpreted as determinants as
// // opposed to sympy.Abs (absolute value) applied to a matrix.
// CMD_BEGIN_AMSPMATRIX_AMSBMATRIX: CMD_BEGIN (AMSMATH_PMATRIX | AMSMATH_BMATRIX)
// CMD_BEGIN_ARRAY_AMSMATRIX: (L_PAREN | L_BRACKET) IGNORE_L CMD_BEGIN (ARRAY_MATRIX_BEGIN | AMSMATH_MATRIX)
// CMD_MATRIX_BEGIN: CMD_BEGIN_AMSPMATRIX_AMSBMATRIX | CMD_BEGIN_ARRAY_AMSMATRIX
// CMD_END_AMSPMATRIX_AMSBMATRIX: CMD_END (AMSMATH_PMATRIX | AMSMATH_BMATRIX)
// CMD_END_ARRAY_AMSMATRIX: CMD_END (ARRAY_MATRIX_END | AMSMATH_MATRIX) IGNORE_R "\\right"? (R_PAREN | R_BRACKET)
// CMD_MATRIX_END: CMD_END_AMSPMATRIX_AMSBMATRIX | CMD_END_ARRAY_AMSMATRIX
// FUNC_MATRIX_TRACE: "\\trace"
// FUNC_MATRIX_ADJUGATE: "\\adjugate"

// // determinants
// AMSMATH_VMATRIX: L_BRACE "vmatrix" R_BRACE
// CMD_DETERMINANT_BEGIN_SIMPLE: CMD_BEGIN AMSMATH_VMATRIX
// CMD_DETERMINANT_BEGIN_VARIANT: BAR IGNORE_L CMD_BEGIN (ARRAY_MATRIX_BEGIN | AMSMATH_MATRIX)
// CMD_DETERMINANT_BEGIN: CMD_DETERMINANT_BEGIN_SIMPLE | CMD_DETERMINANT_BEGIN_VARIANT
// CMD_DETERMINANT_END_SIMPLE: CMD_END AMSMATH_VMATRIX
// CMD_DETERMINANT_END_VARIANT: CMD_END (ARRAY_MATRIX_END | AMSMATH_MATRIX) IGNORE_R "\\right"? BAR
// CMD_DETERMINANT_END: CMD_DETERMINANT_END_SIMPLE | CMD_DETERMINANT_END_VARIANT
// FUNC_DETERMINANT: "\\det"
