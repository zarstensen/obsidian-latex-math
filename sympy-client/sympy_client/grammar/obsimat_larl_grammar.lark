// Based on sympy's original latex.lark: https://github.com/sympy/sympy/blob/2e7baea39cd0d891433bdc2ef2222e445c381ca3/sympy/parsing/latex/lark/grammar/latex.lark



//////////////////// grammar //////////////////////

latex_string: expression

// an expression is a sum of terms
expression: term? ((ADD|SUB) term)*

// singular symbols are also seen as multiplications, as these are just implicitly 1 * SYMBOL
// a term is a series of products of factors
// a term is a product of factors
// how can this be a mandatory whitespace thing?
// AS
term: implicit_multiplication ((OPERATOR_MUL|OPERATOR_DIV) (ADD|SUB)? implicit_multiplication)*
?implicit_multiplication: _factor+

// a _factor is either a constant, a symbol, an exponentiation (again a function), a function (frac is seen as a function in this case), or an expression surrounded by parenthesees (also a function).
// MD
_factor: exponentiation // this should be a multi letter symbol. but again this needs to be placed in to two separate things i guess.
    | _base_factor

_base_factor: _function
    | undefined_function
    | _number
    | symbol

// there should be a _factor rule which matches _factors which can be passed as arguments to functions, without surrounding them with braces.
// then the other one should be all the other ones, which require them to be surrounded by braces. (like matrices, multi letter symbols, functions (except for frac for some reason. there are probably other ones as well))


// ok so functions should be split up into the following categories:
// exponentiable:
//    almost all are, except for the exponentiation function, alternatively it should be non_exponentiable if lark allows an and operation between rules.
//      even more alternatively, perhaps exponentiation should not be considered a function?
// passable (this should probably be named differently):
//    This funtion can (even if its arguments are passed without braces) be passed to other functions without surrounding it with braces.
// empty arg taking (definetly a different name):
//    This function can take passable functions as an argument not surrounded with braces (sqrt is not part of this).

// again this is also technically a function? but it cannot use the template, it should use the wierd arg terminal though
// E
exponentiation: (braces_expression | _base_factor) CARET _function_parameter

// this is just an expression surrounded by parenthesees?
// P
parenthesees_expression: L_PAREN expression R_PAREN
braces_expression: L_BRACE expression R_BRACE

// ======== End OF PEMDAS setup ========

single_letter_symbol: SINGLE_LETTER_SYMBOL
multi_letter_symbol: MULTI_LETTER_SYMBOL


_non_indexed_symbol: single_letter_symbol | multi_letter_symbol

unit: L_BRACE _non_indexed_symbol R_BRACE

_non_indexed_unit_symbol: _non_indexed_symbol | unit

// TODO: check if _non_indexed_symbol accepts primes.
indexed_symbol: _non_indexed_symbol UNDERSCORE (SINGLE_LETTER_SYMBOL | _digit | brace_surrounded_text) PRIMES?

// symbols: DO THE SUBSTITUTION HERE
symbol: _non_indexed_unit_symbol | indexed_symbol

brace_surrounded_text: L_BRACE /[^}]+/ (brace_surrounded_text /[^}]+/)?  R_BRACE

_constant: CONST_PI | CONST_EULER | CONST_IMAGINARY | CONST_INFINITY
// it may be a bit counter intuitive, but here pi (and other constants) are essentially seen as a "_digit".
_numeric_digit: DIGIT
_numeric_number: NUMBER

_digit: _numeric_digit | _constant
_number: _numeric_number | _digit

_function: parenthesees_expression
    | trig_function
    | sqrt
    | frac
    | binom

_function_first_parameter: _function_parameter | frac // fraction can be passed without braces as the first parameter for some reason, EXCEPT to the fraction function itself.
_function_parameter: braces_expression | parenthesees_expression | SINGLE_LETTER_SYMBOL | _digit

undefined_function: UNDEFINED_FUNC_START expression R_PAREN

// functions

_func_template{func_name}: func_name _function_parameter | func_name CARET _function_first_parameter _function_parameter

// core functions

frac: FUNC_FRAC _function_parameter~2
binom: FUNC_BINOM _function_parameter~2
sqrt: FUNC_SQRT (L_BRACKET expression R_BRACKET)? _function_first_parameter
inner_product: CMD_LANGLE expression CMD_INNER_PRODUCT_SEPARATOR expression CMD_RANGLE

// trigonometric functions

trig_function: _func_template{FUNC_SIN}
    | _func_template{FUNC_COS}
    | _func_template{FUNC_TAN}
    | _func_template{FUNC_CSC}
    | _func_template{FUNC_SEC}
    | _func_template{FUNC_COT}
    | _func_template{FUNC_ARCSIN}
    | _func_template{FUNC_ARCCOS}
    | _func_template{FUNC_ARCTAN}
    | _func_template{FUNC_ARCCSC}
    | _func_template{FUNC_ARCSEC}
    | _func_template{FUNC_ARCCOT}
    | _func_template{FUNC_SINH}
    | _func_template{FUNC_COSH}
    | _func_template{FUNC_TANH}
    | _func_template{FUNC_ARSINH}
    | _func_template{FUNC_ARCOSH}
    | _func_template{FUNC_ARTANH}


// ================ Terminals ================

UNDEFINED_FUNC_START: SINGLE_LETTER_SYMBOL L_PAREN | MULTI_LETTER_SYMBOL L_PAREN

// ignore escaped whitespace in latex code
%ignore /(?<!\\)\\ /

%ignore /[ \t\n\r]+/

%ignore "\\," | "\\thinspace" | "\\:" | "\\medspace" | "\\;" | "\\thickspace"
%ignore "\\quad" | "\\qquad"
%ignore "\\!" | "\\negthinspace" | "\\negmedspace" | "\\negthickspace"
%ignore "\\vrule" | "\\vcenter" | "\\vbox" | "\\vskip" | "\\vspace" | "\\hfill"
%ignore "\\*" | "\\-" | "\\." | "\\/" | "\\(" | "\\=" | "\\middle"

%ignore "\\left" | "\\right"
%ignore "\\limits" | "\\nolimits"
%ignore "\\displaystyle"

///////////////////// tokens ///////////////////////

// basic binary operators
ADD: "+"
SUB: "-"
MUL: "*"
DIV: "/" | "\\over"

// non basic operators
CMD_TIMES: "\\times"
CMD_CDOT:  "\\cdot"
CMD_DIV:   "\\div"
CMD_LANGLE: "\\langle"
CMD_RANGLE: "\\rangle"
CMD_INNER_PRODUCT_SEPARATOR: BAR | COMMA

// tokens with distinct left and right symbols
L_BRACE: "{"
R_BRACE: "}"
L_BRACE_LITERAL: "\\{"
R_BRACE_LITERAL: "\\}"
L_BRACKET: "["
R_BRACKET: "]"
L_CEIL: "\\lceil"
R_CEIL: "\\rceil"
L_FLOOR: "\\lfloor"
R_FLOOR: "\\rfloor"
L_PAREN: "("
R_PAREN: ")"

// limit, integral, sum, and product symbols
FUNC_LIMIT:  "\\lim"
LIM_APPROACH_SYMBOL: "\\to" | "\\rightarrow" | "\\Rightarrow" | "\\longrightarrow" | "\\Longrightarrow"
FUNC_INTEGRAL:  "\\int" | "\\intop"
FUNC_SUM:  "\\sum"
FUNC_PRODUCT: "\\prod"

// common functions
FUNC_EXP:  "\\exp"
FUNC_LOG:  "\\log"
FUNC_LN:   "\\ln"
FUNC_LG:   "\\lg"
FUNC_MIN: "\\min"
FUNC_MAX: "\\max"

// special functions

FUNC_FRAC:  /\\[dtcs]?frac/ | "\\nicefrac"
FUNC_BINOM: /\\[dt]?binom/
FUNC_OVERLINE: "\\overline"

// trigonometric functions
FUNC_SIN:  "\\sin"
FUNC_COS:  "\\cos"
FUNC_TAN:  "\\tan"
FUNC_CSC:  "\\csc"
FUNC_SEC:  "\\sec"
FUNC_COT:  "\\cot"

// inverse trigonometric functions
FUNC_ARCSIN: "\\arcsin"
FUNC_ARCCOS: "\\arccos"
FUNC_ARCTAN: "\\arctan"
FUNC_ARCCSC: "\\arccsc"
FUNC_ARCSEC: "\\arcsec"
FUNC_ARCCOT: "\\arccot"

// hyperbolic trigonometric functions
FUNC_SINH: "\\sinh"
FUNC_COSH: "\\cosh"
FUNC_TANH: "\\tanh"
FUNC_ARSINH: "\\arsinh"
FUNC_ARCOSH: "\\arcosh"
FUNC_ARTANH: "\\artanh"

FUNC_SQRT: "\\sqrt"

// mathematical constants
CONST_PI: "\\pi"
CONST_EULER: "e"
CONST_IMAGINARY: "i"
CONST_INFINITY: "\\infty"

CMD_MATH: /\\math\w+/
CMD_BOLD_FORMAT: "\\pmb"

CMD_FORMAT: CMD_MATH | CMD_BOLD_FORMAT

BANG: "!"
BAR: "|"
DOT: "."
CARET: "^"
COLON: ":"
COMMA: ","
UNDERSCORE: "_"

// relational symbols
EQUAL: "="
NOT_EQUAL: "\\neq" | "\\ne"
LT: "<"
LTE: "\\leq" | "\\le" | "\\leqslant"
GT: ">"
GTE: "\\geq" | "\\ge" | "\\geqslant"

OPERATOR_DIV: CMD_DIV | DIV
OPERATOR_MUL: MUL | CMD_TIMES | CMD_CDOT

%import .greek_symbols.GREEK_SYMBOL

UPRIGHT_DIFFERENTIAL_SYMBOL: "\\text{d}" | "\\mathrm{d}"
DIFFERENTIAL_SYMBOL: "d" | UPRIGHT_DIFFERENTIAL_SYMBOL

// disallow "d" as a variable name because we want to parse "d" as a differential symbol.
// should this just be \w?
LATIN_SYMBOL: /[a-zA-Z]/
LATIN_SYMBOL_WITH_PRIMTES: LATIN_SYMBOL PRIMES
MULTI_LETTER_LATIN_SYMBOL: /[a-zA-Z]{2,}'*/
GREEK_SYMBOL_WITH_PRIMES: GREEK_SYMBOL PRIMES

SINGLE_LETTER_SYMBOL: LATIN_SYMBOL | GREEK_SYMBOL

MULTI_LETTER_SYMBOL: LATIN_SYMBOL_WITH_PRIMTES | GREEK_SYMBOL_WITH_PRIMES | MULTI_LETTER_LATIN_SYMBOL

%import common.DIGIT -> DIGIT

NUMBER: DIGIT DIGIT+ | DIGIT* DOT DIGIT+

CMD_PRIME: "\\prime"
CMD_ASTERISK: "\\ast"

PRIMES: "'"+
STARS: "*"+
PRIMES_VIA_CMD: CMD_PRIME+
STARS_VIA_CMD: CMD_ASTERISK+

CMD_IMAGINARY_UNIT: "\\imaginaryunit"

CMD_BEGIN: "\\begin"
CMD_END: "\\end"

// matrices
IGNORE_L: /[ \t\n\r]*/ L_BRACE* /[ \t\n\r]*/
IGNORE_R: /[ \t\n\r]*/ R_BRACE* /[ \t\n\r]*/
ARRAY_MATRIX_BEGIN: L_BRACE "array" R_BRACE L_BRACE /[^}]*/ R_BRACE
ARRAY_MATRIX_END: L_BRACE "array" R_BRACE
AMSMATH_MATRIX: L_BRACE "matrix" R_BRACE
AMSMATH_PMATRIX: L_BRACE "pmatrix" R_BRACE
AMSMATH_BMATRIX: L_BRACE "bmatrix" R_BRACE
// Without the (L|R)_PARENs and (L|R)_BRACKETs, a matrix defined using
// \begin{array}...\end{array} or \begin{matrix}...\end{matrix} must
// not qualify as a complete matrix expression; this is done so that
// if we have \begin{array}...\end{array} or \begin{matrix}...\end{matrix}
// between BAR pairs, then they should be interpreted as determinants as
// opposed to sympy.Abs (absolute value) applied to a matrix.
CMD_BEGIN_AMSPMATRIX_AMSBMATRIX: CMD_BEGIN (AMSMATH_PMATRIX | AMSMATH_BMATRIX)
CMD_BEGIN_ARRAY_AMSMATRIX: (L_PAREN | L_BRACKET) IGNORE_L CMD_BEGIN (ARRAY_MATRIX_BEGIN | AMSMATH_MATRIX)
CMD_MATRIX_BEGIN: CMD_BEGIN_AMSPMATRIX_AMSBMATRIX | CMD_BEGIN_ARRAY_AMSMATRIX
CMD_END_AMSPMATRIX_AMSBMATRIX: CMD_END (AMSMATH_PMATRIX | AMSMATH_BMATRIX)
CMD_END_ARRAY_AMSMATRIX: CMD_END (ARRAY_MATRIX_END | AMSMATH_MATRIX) IGNORE_R "\\right"? (R_PAREN | R_BRACKET)
CMD_MATRIX_END: CMD_END_AMSPMATRIX_AMSBMATRIX | CMD_END_ARRAY_AMSMATRIX
MATRIX_COL_DELIM: "&"
MATRIX_ROW_DELIM: "\\\\"
FUNC_MATRIX_TRACE: "\\trace"
FUNC_MATRIX_ADJUGATE: "\\adjugate"

// determinants
AMSMATH_VMATRIX: L_BRACE "vmatrix" R_BRACE
CMD_DETERMINANT_BEGIN_SIMPLE: CMD_BEGIN AMSMATH_VMATRIX
CMD_DETERMINANT_BEGIN_VARIANT: BAR IGNORE_L CMD_BEGIN (ARRAY_MATRIX_BEGIN | AMSMATH_MATRIX)
CMD_DETERMINANT_BEGIN: CMD_DETERMINANT_BEGIN_SIMPLE | CMD_DETERMINANT_BEGIN_VARIANT
CMD_DETERMINANT_END_SIMPLE: CMD_END AMSMATH_VMATRIX
CMD_DETERMINANT_END_VARIANT: CMD_END (ARRAY_MATRIX_END | AMSMATH_MATRIX) IGNORE_R "\\right"? BAR
CMD_DETERMINANT_END: CMD_DETERMINANT_END_SIMPLE | CMD_DETERMINANT_END_VARIANT
FUNC_DETERMINANT: "\\det"
