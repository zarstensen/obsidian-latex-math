// Terminals are largely based on sympy's original latex.lark: https://github.com/sympy/sympy/blob/2e7baea39cd0d891433bdc2ef2222e445c381ca3/sympy/parsing/latex/lark/grammar/latex.lark
// grammar has been written from the ground up to support the faster lalr parser instead of earley.

// ======== Core structure ========

latex_string: expression

// an expression is a sum of terms
expression: term? ((ADD|SUB) term)*

// a term is a series of products of factors separated by product operators.
term: implicit_multiplication ((OPERATOR_MUL|OPERATOR_DIV) (ADD|SUB)? implicit_multiplication)*
// factors with no operator between them are implicitly multiplied together.
?implicit_multiplication: _factor+

// a factor is either a number, a constant, a symbol, or a function.
// here exponentiation, fractions, binomials are loosly seen as functions.
_factor: exponentiation
    | _base_factor

// _base_factor groups all factors which can be the base value of an exponentiation.
_base_factor: parenthesees_expression
    | _function
    | _symbol_like
    | _number

// groups a base factor and an exponent factor to be evaluated in an exponentation.
exponentiation: (braces_expression | _base_factor) CARET _function_special_arg

// various rules for grouping expressions surrounded by delimiters.
parenthesees_expression: L_PAREN expression R_PAREN -> delimited_expression
braces_expression: L_BRACE expression R_BRACE -> delimited_expression
brackets_expression: L_BRACKET expression R_BRACKET -> delimited_expression

// ======== Symbols ========

symbol: indexed_symbol | _non_indexed_symbol

single_letter_symbol: SINGLE_LETTER_SYMBOL -> symbol

// a formatted symbol is any symbol surrounded with a latex command which changes it visually.
// this could for example be \mathit
formatted_symbol: (CMD_MATH|CMD_BOLD_FORMAT) brace_surrounded_text PRIMES?
_non_indexed_symbol: SINGLE_LETTER_SYMBOL | MULTI_LETTER_SYMBOL | formatted_symbol

indexed_symbol: _non_indexed_symbol UNDERSCORE (SINGLE_LETTER_SYMBOL | _digit | brace_surrounded_text) PRIMES?

// all the rules here should return the NAME (as in a str) of the symbol to be created
// the symbol rule is responsible for eactually creating the symbol and optionally substituting its value.

// this rule optionally tries to create a unit, instead of a symbol, if bunits are used.
// otherwise this is the same as the symbol rule.
unit: L_BRACE _non_indexed_symbol R_BRACE

_symbol_like: symbol | unit

// ======== Numbers ========

// groups any value which evaluates to a number.
_number: _numeric_number | _digit
// groups any value which evaluates to a number, and can be passed as an argument, without surrounding it with braces.
// it may be a bit counter intuitive, but here pi (and other constants) are essentially seen as a "_digit".
_digit: _numeric_digit | _constant

_constant: CONST_PI | CONST_EULER | CONST_IMAGINARY | CONST_INFINITY

_numeric_digit: NUMERIC_DIGIT
_numeric_number: NUMERIC_NUMBER

// ======== Functions ========

undefined_function: UNDEFINED_FUNC_START expression R_PAREN

_function: undefined_function
    | trig_function
    | _log
    | sqrt
    | frac
    | binom

// this rule matches a singular argument to a function.
// if a function takes multiple non special arguments, _multiarg_func_arg should be used instead.
_function_arg: braces_expression | parenthesees_expression | single_letter_symbol | _digit // parenthesees_expression should maybe not be here. it does not render properly in all cases, but it is very convenient...

// matches a special kind of argument, defined by the fact that fractions and binomials can be passed without surrounding them with braces.
_function_special_arg: _function_arg | frac | binom 

// standard 1 arg functions

_func_template{func_name}: func_name (CARET _function_special_arg)? _function_arg

// trigonometric functions

trig_function: _func_template{FUNC_SIN}
    | _func_template{FUNC_COS}
    | _func_template{FUNC_TAN}
    | _func_template{FUNC_CSC}
    | _func_template{FUNC_SEC}
    | _func_template{FUNC_COT}
    | _func_template{FUNC_ARCSIN}
    | _func_template{FUNC_ARCCOS}
    | _func_template{FUNC_ARCTAN}
    | _func_template{FUNC_ARCCSC}
    | _func_template{FUNC_ARCSEC}
    | _func_template{FUNC_ARCCOT}
    | _func_template{FUNC_SINH}
    | _func_template{FUNC_COSH}
    | _func_template{FUNC_TANH}
    | _func_template{FUNC_ARSINH}
    | _func_template{FUNC_ARCOSH}
    | _func_template{FUNC_ARTANH}

_log: log_implicit_base
    | log_explicit_base

log_implicit_base: _func_template{FUNC_LOG}
    | _func_template{FUNC_LN}
    | _func_template{FUNC_LG}
 
log_explicit_base: FUNC_LOG UNDERSCORE _function_special_arg (CARET _function_special_arg)? _function_arg

exponential: _func_template{FUNC_EXP}

sqrt: FUNC_SQRT brackets_expression? (braces_expression|single_letter_symbol|_digit)
inner_product: CMD_LANGLE expression CMD_INNER_PRODUCT_SEPARATOR expression CMD_RANGLE

// TODO: wait for matrix implementation.
// determinant: _func_template{FUNC_DETERMINANT}
// trace: _func_template{FUNC_MATRIX_TRACE}
// adjungate: _func_template{FUNC_MATRIX_ADJUGATE}

// match a single argument in a list of arguments latex style (that is \command{arg1}{arg2}...{argN})
_multiarg_func_arg: (braces_expression|single_letter_symbol|_digit)
// terminal signifying the end of a single argument in a latex style argument list.
// due to lalr's limited lookahead, a custom post lexer needs to insert this token when parsing.
// this also requires a bit more setup in the grammar for this to work, which is specified in the following comment.
//
// this token should be placed between _multiarg_func_arg rules when specifying the list of arguments.
// additionally, there must be a terminal before the first _multiarg_func_arg rule, which follows the following naming convention:
// MULTIARG_FUNC_[num_args][terminal_name]
// num_args: number of arguments this function takes. This must be number of MULTIARG_FUNC_ARG_DELIMITER occurenses + 1
// terminal_name: this is ignored by the postlexer and can be used to name the terminal appropiately.
%declare MULTIARG_FUNC_ARG_DELIMITER

// core functions
frac: MULTIARG_FUNC_2_FRAC _multiarg_func_arg MULTIARG_FUNC_ARG_DELIMITER _multiarg_func_arg
binom: MULTIARG_FUNC_2_BINOM _multiarg_func_arg MULTIARG_FUNC_ARG_DELIMITER _multiarg_func_arg

// ======== Miscellaneous rules ========

brace_surrounded_text: L_BRACE /[^{}]+/ (brace_surrounded_text /[^{}]+/?)?  R_BRACE

// ================ Terminals ================

// ignore escaped whitespace in latex code
%ignore /(?<!\\)\\ /

%ignore /[ \t\n\r]+/

%ignore "\\," | "\\thinspace" | "\\:" | "\\medspace" | "\\;" | "\\thickspace"
%ignore "\\quad" | "\\qquad"
%ignore "\\!" | "\\negthinspace" | "\\negmedspace" | "\\negthickspace"
%ignore "\\vrule" | "\\vcenter" | "\\vbox" | "\\vskip" | "\\vspace" | "\\hfill"
%ignore "\\*" | "\\-" | "\\." | "\\/" | "\\(" | "\\=" | "\\middle"

%ignore "\\left" | "\\right"
%ignore "\\limits" | "\\nolimits"
%ignore "\\displaystyle"

// basic binary operators
ADD: "+"
SUB: "-"
MUL: "*"
DIV: "/" | "\\over"

// basic common operators
CMD_TIMES: "\\times"
CMD_CDOT:  "\\cdot"
CMD_DIV:   "\\div"
CMD_LANGLE: "\\langle"
CMD_RANGLE: "\\rangle"
CMD_INNER_PRODUCT_SEPARATOR: BAR | COMMA

// tokens with distinct left and right symbols
L_BRACE: "{"
R_BRACE: "}"
L_BRACE_LITERAL: "\\{"
R_BRACE_LITERAL: "\\}"
L_BRACKET: "["
R_BRACKET: "]"
L_CEIL: "\\lceil"
R_CEIL: "\\rceil"
L_FLOOR: "\\lfloor"
R_FLOOR: "\\rfloor"
L_PAREN: "("
R_PAREN: ")"

// limit, integral, sum, and product symbols
FUNC_LIMIT:  "\\lim"
LIM_APPROACH_SYMBOL: "\\to" | "\\rightarrow" | "\\Rightarrow" | "\\longrightarrow" | "\\Longrightarrow"
FUNC_INTEGRAL:  "\\int" | "\\intop"
FUNC_SUM:  "\\sum"
FUNC_PRODUCT: "\\prod"

// common functions
FUNC_EXP:  "\\exp"
FUNC_LOG:  "\\log"
FUNC_LN:   "\\ln"
FUNC_LG:   "\\lg"
FUNC_MIN: "\\min"
FUNC_MAX: "\\max"

// multiarg functions

MULTIARG_FUNC_2_FRAC: /\\[dtcs]?frac/ | "\\nicefrac"
MULTIARG_FUNC_2_BINOM: /\\[dt]?binom/

FUNC_OVERLINE: "\\overline"

// trigonometric functions
FUNC_SIN:  "\\sin"
FUNC_COS:  "\\cos"
FUNC_TAN:  "\\tan"
FUNC_CSC:  "\\csc"
FUNC_SEC:  "\\sec"
FUNC_COT:  "\\cot"

// inverse trigonometric functions
FUNC_ARCSIN: "\\arcsin"
FUNC_ARCCOS: "\\arccos"
FUNC_ARCTAN: "\\arctan"
FUNC_ARCCSC: "\\arccsc"
FUNC_ARCSEC: "\\arcsec"
FUNC_ARCCOT: "\\arccot"

// hyperbolic trigonometric functions
FUNC_SINH: "\\sinh"
FUNC_COSH: "\\cosh"
FUNC_TANH: "\\tanh"
FUNC_ARSINH: "\\arsinh"
FUNC_ARCOSH: "\\arcosh"
FUNC_ARTANH: "\\artanh"

FUNC_SQRT: "\\sqrt"

UNDEFINED_FUNC_START: SINGLE_LETTER_SYMBOL L_PAREN | MULTI_LETTER_SYMBOL L_PAREN

// mathematical constants
CONST_PI: "\\pi"
CONST_EULER: "e"
CONST_IMAGINARY: "i"
CONST_INFINITY: "\\infty"

CMD_MATH: /\\math\w+/
CMD_BOLD_FORMAT: "\\pmb"

CMD_FORMAT: CMD_MATH | CMD_BOLD_FORMAT

BANG: "!"
BAR: "|"
DOT: "."
CARET: "^"
COLON: ":"
COMMA: ","
UNDERSCORE: "_"

// relational symbols
EQUAL: "="
NOT_EQUAL: "\\neq" | "\\ne"
LT: "<"
LTE: "\\leq" | "\\le" | "\\leqslant"
GT: ">"
GTE: "\\geq" | "\\ge" | "\\geqslant"

OPERATOR_DIV: CMD_DIV | DIV
OPERATOR_MUL: MUL | CMD_TIMES | CMD_CDOT

%import .greek_symbols.GREEK_SYMBOL

UPRIGHT_DIFFERENTIAL_SYMBOL: "\\text{d}" | "\\mathrm{d}"
DIFFERENTIAL_SYMBOL: "d" | UPRIGHT_DIFFERENTIAL_SYMBOL

// should this just be \w?
LATIN_SYMBOL: /[a-zA-Z]/
LATIN_SYMBOL_WITH_PRIMTES: LATIN_SYMBOL PRIMES
MULTI_LETTER_LATIN_SYMBOL: /[a-zA-Z]{2,}'*/
GREEK_SYMBOL_WITH_PRIMES: GREEK_SYMBOL PRIMES

SINGLE_LETTER_SYMBOL: LATIN_SYMBOL | GREEK_SYMBOL

MULTI_LETTER_SYMBOL: LATIN_SYMBOL_WITH_PRIMTES | GREEK_SYMBOL_WITH_PRIMES | MULTI_LETTER_LATIN_SYMBOL

%import common.DIGIT -> NUMERIC_DIGIT

NUMERIC_NUMBER: NUMERIC_DIGIT NUMERIC_DIGIT+ | NUMERIC_DIGIT* DOT NUMERIC_DIGIT+

CMD_PRIME: "\\prime"
CMD_ASTERISK: "\\ast"

PRIMES: "'"+
STARS: "*"+
PRIMES_VIA_CMD: CMD_PRIME+
STARS_VIA_CMD: CMD_ASTERISK+

CMD_IMAGINARY_UNIT: "\\imaginaryunit"

CMD_BEGIN: "\\begin"
CMD_END: "\\end"

// matrices
IGNORE_L: /[ \t\n\r]*/ L_BRACE* /[ \t\n\r]*/
IGNORE_R: /[ \t\n\r]*/ R_BRACE* /[ \t\n\r]*/
ARRAY_MATRIX_BEGIN: L_BRACE "array" R_BRACE L_BRACE /[^}]*/ R_BRACE
ARRAY_MATRIX_END: L_BRACE "array" R_BRACE
AMSMATH_MATRIX: L_BRACE "matrix" R_BRACE
AMSMATH_PMATRIX: L_BRACE "pmatrix" R_BRACE
AMSMATH_BMATRIX: L_BRACE "bmatrix" R_BRACE
// Without the (L|R)_PARENs and (L|R)_BRACKETs, a matrix defined using
// \begin{array}...\end{array} or \begin{matrix}...\end{matrix} must
// not qualify as a complete matrix expression; this is done so that
// if we have \begin{array}...\end{array} or \begin{matrix}...\end{matrix}
// between BAR pairs, then they should be interpreted as determinants as
// opposed to sympy.Abs (absolute value) applied to a matrix.
CMD_BEGIN_AMSPMATRIX_AMSBMATRIX: CMD_BEGIN (AMSMATH_PMATRIX | AMSMATH_BMATRIX)
CMD_BEGIN_ARRAY_AMSMATRIX: (L_PAREN | L_BRACKET) IGNORE_L CMD_BEGIN (ARRAY_MATRIX_BEGIN | AMSMATH_MATRIX)
CMD_MATRIX_BEGIN: CMD_BEGIN_AMSPMATRIX_AMSBMATRIX | CMD_BEGIN_ARRAY_AMSMATRIX
CMD_END_AMSPMATRIX_AMSBMATRIX: CMD_END (AMSMATH_PMATRIX | AMSMATH_BMATRIX)
CMD_END_ARRAY_AMSMATRIX: CMD_END (ARRAY_MATRIX_END | AMSMATH_MATRIX) IGNORE_R "\\right"? (R_PAREN | R_BRACKET)
CMD_MATRIX_END: CMD_END_AMSPMATRIX_AMSBMATRIX | CMD_END_ARRAY_AMSMATRIX
MATRIX_COL_DELIM: "&"
MATRIX_ROW_DELIM: "\\\\"
FUNC_MATRIX_TRACE: "\\trace"
FUNC_MATRIX_ADJUGATE: "\\adjugate"

// determinants
AMSMATH_VMATRIX: L_BRACE "vmatrix" R_BRACE
CMD_DETERMINANT_BEGIN_SIMPLE: CMD_BEGIN AMSMATH_VMATRIX
CMD_DETERMINANT_BEGIN_VARIANT: BAR IGNORE_L CMD_BEGIN (ARRAY_MATRIX_BEGIN | AMSMATH_MATRIX)
CMD_DETERMINANT_BEGIN: CMD_DETERMINANT_BEGIN_SIMPLE | CMD_DETERMINANT_BEGIN_VARIANT
CMD_DETERMINANT_END_SIMPLE: CMD_END AMSMATH_VMATRIX
CMD_DETERMINANT_END_VARIANT: CMD_END (ARRAY_MATRIX_END | AMSMATH_MATRIX) IGNORE_R "\\right"? BAR
CMD_DETERMINANT_END: CMD_DETERMINANT_END_SIMPLE | CMD_DETERMINANT_END_VARIANT
FUNC_DETERMINANT: "\\det"
