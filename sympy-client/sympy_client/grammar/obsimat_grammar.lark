// Based on sympy's original latex.lark: https://github.com/sympy/sympy/blob/2e7baea39cd0d891433bdc2ef2222e445c381ca3/sympy/parsing/latex/lark/grammar/latex.lark

// ignore escaped whitespace in latex code
%ignore /(?<!\\)\\ /

%ignore /[ \t\n\r]+/

%ignore "\\," | "\\thinspace" | "\\:" | "\\medspace" | "\\;" | "\\thickspace"
%ignore "\\quad" | "\\qquad"
%ignore "\\!" | "\\negthinspace" | "\\negmedspace" | "\\negthickspace"
%ignore "\\vrule" | "\\vcenter" | "\\vbox" | "\\vskip" | "\\vspace" | "\\hfill"
%ignore "\\*" | "\\-" | "\\." | "\\/" | "\\(" | "\\=" | "\\middle"

%ignore "\\left" | "\\right"
%ignore "\\limits" | "\\nolimits"
%ignore "\\displaystyle"

///////////////////// tokens ///////////////////////

// basic binary operators
ADD: "+"
SUB: "-"
MUL: "*"
DIV: "/"

// tokens with distinct left and right symbols
L_BRACE: "{"
R_BRACE: "}"
L_BRACE_LITERAL: "\\{"
R_BRACE_LITERAL: "\\}"
L_BRACKET: "["
R_BRACKET: "]"
L_CEIL: "\\lceil"
R_CEIL: "\\rceil"
L_FLOOR: "\\lfloor"
R_FLOOR: "\\rfloor"
L_PAREN: "("
R_PAREN: ")"

// limit, integral, sum, and product symbols
FUNC_LIM:  "\\lim"
LIM_APPROACH_SYM: "\\to" | "\\rightarrow" | "\\Rightarrow" | "\\longrightarrow" | "\\Longrightarrow"
FUNC_INT:  "\\int" | "\\intop"
FUNC_SUM:  "\\sum"
FUNC_PROD: "\\prod"

// common functions
FUNC_EXP:  "\\exp"
FUNC_LOG:  "\\log"
FUNC_LN:   "\\ln"
FUNC_LG:   "\\lg"
FUNC_MIN: "\\min"
FUNC_MAX: "\\max"

// trigonometric functions
FUNC_SIN:  "\\sin"
FUNC_COS:  "\\cos"
FUNC_TAN:  "\\tan"
FUNC_CSC:  "\\csc"
FUNC_SEC:  "\\sec"
FUNC_COT:  "\\cot"

// inverse trigonometric functions
FUNC_ARCSIN: "\\arcsin"
FUNC_ARCCOS: "\\arccos"
FUNC_ARCTAN: "\\arctan"
FUNC_ARCCSC: "\\arccsc"
FUNC_ARCSEC: "\\arcsec"
FUNC_ARCCOT: "\\arccot"

// hyperbolic trigonometric functions
FUNC_SINH: "\\sinh"
FUNC_COSH: "\\cosh"
FUNC_TANH: "\\tanh"
FUNC_ARSINH: "\\arsinh"
FUNC_ARCOSH: "\\arcosh"
FUNC_ARTANH: "\\artanh"

FUNC_SQRT: "\\sqrt"

// miscellaneous symbols
CMD_TIMES: "\\times"
CMD_CDOT:  "\\cdot"
CMD_DIV:   "\\div"
CMD_FRAC:  "\\frac" | "\\dfrac" | "\\tfrac" | "\\nicefrac"
CMD_BINOM: "\\binom" | "\\dbinom" | "\\tbinom"
CMD_OVERLINE: "\\overline"
CMD_LANGLE: "\\langle"
CMD_RANGLE: "\\rangle"

CMD_MATH: /\\math\w+/
CMD_BOLD_FORMAT: "\\pmb"

CMD_FORMAT: CMD_MATH | CMD_BOLD_FORMAT

CMD_INFTY: "\\infty"

BANG: "!"
BAR: "|"
CARET: "^"
COLON: ":"
UNDERSCORE: "_"

// relational symbols
EQUAL: "="
NOT_EQUAL: "\\neq" | "\\ne"
LT: "<"
LTE: "\\leq" | "\\le" | "\\leqslant"
GT: ">"
GTE: "\\geq" | "\\ge" | "\\geqslant"

DIV_SYMBOL: CMD_DIV | DIV
MUL_SYMBOL: MUL | CMD_TIMES | CMD_CDOT

%import .greek_symbols.GREEK_SYMBOL

UPRIGHT_DIFFERENTIAL_SYMBOL: "\\text{d}" | "\\mathrm{d}"
DIFFERENTIAL_SYMBOL: "d" | UPRIGHT_DIFFERENTIAL_SYMBOL

// disallow "d" as a variable name because we want to parse "d" as a differential symbol.
SYMBOL: /[a-zA-Z]'*/
MULTI_LETTER_SYMBOL: /[a-zA-Z]{2,}'*/
GREEK_SYMBOL_WITH_PRIMES: GREEK_SYMBOL PRIMES*

%import common.DIGIT -> DIGIT

CMD_PRIME: "\\prime"
CMD_ASTERISK: "\\ast"

PRIMES: "'"+
STARS: "*"+
PRIMES_VIA_CMD: CMD_PRIME+
STARS_VIA_CMD: CMD_ASTERISK+

CMD_IMAGINARY_UNIT: "\\imaginaryunit"

CMD_BEGIN: "\\begin"
CMD_END: "\\end"

// matrices
IGNORE_L: /[ \t\n\r]*/ L_BRACE* /[ \t\n\r]*/
IGNORE_R: /[ \t\n\r]*/ R_BRACE* /[ \t\n\r]*/
ARRAY_MATRIX_BEGIN: L_BRACE "array" R_BRACE L_BRACE /[^}]*/ R_BRACE
ARRAY_MATRIX_END: L_BRACE "array" R_BRACE
AMSMATH_MATRIX: L_BRACE "matrix" R_BRACE
AMSMATH_PMATRIX: L_BRACE "pmatrix" R_BRACE
AMSMATH_BMATRIX: L_BRACE "bmatrix" R_BRACE
// Without the (L|R)_PARENs and (L|R)_BRACKETs, a matrix defined using
// \begin{array}...\end{array} or \begin{matrix}...\end{matrix} must
// not qualify as a complete matrix expression; this is done so that
// if we have \begin{array}...\end{array} or \begin{matrix}...\end{matrix}
// between BAR pairs, then they should be interpreted as determinants as
// opposed to sympy.Abs (absolute value) applied to a matrix.
CMD_BEGIN_AMSPMATRIX_AMSBMATRIX: CMD_BEGIN (AMSMATH_PMATRIX | AMSMATH_BMATRIX)
CMD_BEGIN_ARRAY_AMSMATRIX: (L_PAREN | L_BRACKET) IGNORE_L CMD_BEGIN (ARRAY_MATRIX_BEGIN | AMSMATH_MATRIX)
CMD_MATRIX_BEGIN: CMD_BEGIN_AMSPMATRIX_AMSBMATRIX | CMD_BEGIN_ARRAY_AMSMATRIX
CMD_END_AMSPMATRIX_AMSBMATRIX: CMD_END (AMSMATH_PMATRIX | AMSMATH_BMATRIX)
CMD_END_ARRAY_AMSMATRIX: CMD_END (ARRAY_MATRIX_END | AMSMATH_MATRIX) IGNORE_R "\\right"? (R_PAREN | R_BRACKET)
CMD_MATRIX_END: CMD_END_AMSPMATRIX_AMSBMATRIX | CMD_END_ARRAY_AMSMATRIX
MATRIX_COL_DELIM: "&"
MATRIX_ROW_DELIM: "\\\\"
FUNC_MATRIX_TRACE: "\\trace"
FUNC_MATRIX_ADJUGATE: "\\adjugate"

// determinants
AMSMATH_VMATRIX: L_BRACE "vmatrix" R_BRACE
CMD_DETERMINANT_BEGIN_SIMPLE: CMD_BEGIN AMSMATH_VMATRIX
CMD_DETERMINANT_BEGIN_VARIANT: BAR IGNORE_L CMD_BEGIN (ARRAY_MATRIX_BEGIN | AMSMATH_MATRIX)
CMD_DETERMINANT_BEGIN: CMD_DETERMINANT_BEGIN_SIMPLE | CMD_DETERMINANT_BEGIN_VARIANT
CMD_DETERMINANT_END_SIMPLE: CMD_END AMSMATH_VMATRIX
CMD_DETERMINANT_END_VARIANT: CMD_END (ARRAY_MATRIX_END | AMSMATH_MATRIX) IGNORE_R "\\right"? BAR
CMD_DETERMINANT_END: CMD_DETERMINANT_END_SIMPLE | CMD_DETERMINANT_END_VARIANT
FUNC_DETERMINANT: "\\det"

//////////////////// grammar //////////////////////

latex_string: _relation | _expression

// matches any text surrounded by braces. Also suports nested brace surrounded text.
_brace_surrounded_text: L_BRACE /[^{}]+/? (_brace_surrounded_text /[^{}]+/?)* R_BRACE

// match any one 'letter' symbol.
// this aims to match symbols which are rendered as one letter, and not necesarrily consists of one letter in latex source.
// f.ex. \alpha is considered a letter.
_one_letter_symbol: SYMBOL | GREEK_SYMBOL PRIMES?

_multi_letter_symbol: MULTI_LETTER_SYMBOL

_formatted_multi_letter_symbol: CMD_FORMAT _brace_surrounded_text PRIMES?

_non_indexed_symbol:  _multi_letter_symbol | _formatted_multi_letter_symbol | _one_letter_symbol

// match any symbol which has also been indexed (that is SYMBOL_INDEX)
_indexed_symbol: _non_indexed_symbol UNDERSCORE _brace_surrounded_text PRIMES?
    | _non_indexed_symbol UNDERSCORE (DIGIT | _one_letter_symbol | _formatted_multi_letter_symbol) PRIMES?

symbol: _indexed_symbol | _non_indexed_symbol
brace_surrounded_symbol: L_BRACE _non_indexed_symbol R_BRACE

// TODO: change this so e+xxx syntax is also supported
number: /\d+(\.\d*)?/ | CMD_IMAGINARY_UNIT

_atomic_expr: symbol
    | number
    | CMD_INFTY

group_round_parentheses: L_PAREN _expression R_PAREN
group_square_brackets: L_BRACKET _expression R_BRACKET
group_curly_parentheses: L_BRACE _expression R_BRACE

_relation: eq | ne | lt | lte | gt | gte

eq: _expression EQUAL _expression
ne: _expression NOT_EQUAL _expression
lt: _expression LT _expression
lte: _expression LTE _expression
gt: _expression GT _expression
gte: _expression GTE _expression

_expression_core: _atomic_expr | group_curly_parentheses

add: _expression ADD _expression_mul
    | ADD _expression_mul
sub: _expression SUB _expression_mul
    | SUB _expression_mul
mul: _expression_mul MUL_SYMBOL _expression_power
div: _expression_mul DIV_SYMBOL _expression_power

adjacent_expressions: (_one_letter_symbol | number) _expression_mul
    | group_round_parentheses (group_round_parentheses | _one_letter_symbol)
    | _function _function
    | fraction _expression_mul

_non_brace_surrounded_expression: group_round_parentheses
    | fraction
    | binomial
    | _function
    | _integral// | derivative
    | limit
    | matrix

_expression_func: _expression_core | _non_brace_surrounded_expression


expression_func_args: L_BRACE _expression R_BRACE | _non_brace_surrounded_expression

_expression_power: _expression_func | superscript | matrix_prime | symbol_prime

_expression_mul: _expression_power
    | mul | div | adjacent_expressions
    | summation | product

_expression: _expression_mul | add | sub

_limit_dir: "+" | "-" | L_BRACE ("+" | "-") R_BRACE

limit_dir_expr: _expression CARET _limit_dir

group_curly_parentheses_lim: L_BRACE _expression LIM_APPROACH_SYM (limit_dir_expr | _expression) R_BRACE

limit: FUNC_LIM UNDERSCORE group_curly_parentheses_lim _expression

differential: DIFFERENTIAL_SYMBOL _one_letter_symbol

//_derivative_operator: CMD_FRAC L_BRACE DIFFERENTIAL_SYMBOL R_BRACE L_BRACE differential R_BRACE

//derivative: _derivative_operator _expression

_integral: normal_integral | integral_with_special_fraction

normal_integral: FUNC_INT _expression DIFFERENTIAL_SYMBOL _one_letter_symbol
    | FUNC_INT (CARET _expression_core UNDERSCORE _expression_core)? _expression? DIFFERENTIAL_SYMBOL _one_letter_symbol
    | FUNC_INT (UNDERSCORE _expression_core CARET _expression_core)? _expression? DIFFERENTIAL_SYMBOL _one_letter_symbol

group_curly_parentheses_int: L_BRACE _expression? differential R_BRACE

special_fraction: CMD_FRAC group_curly_parentheses_int group_curly_parentheses

integral_with_special_fraction: FUNC_INT special_fraction
    | FUNC_INT (CARET _expression_core UNDERSCORE _expression_core)? special_fraction
    | FUNC_INT (UNDERSCORE _expression_core CARET _expression_core)? special_fraction

group_curly_parentheses_special: UNDERSCORE L_BRACE _atomic_expr EQUAL _atomic_expr R_BRACE CARET _expression_core
    | CARET _expression_core UNDERSCORE L_BRACE _atomic_expr EQUAL _atomic_expr R_BRACE

summation: FUNC_SUM group_curly_parentheses_special _expression
    | FUNC_SUM group_curly_parentheses_special _expression

product: FUNC_PROD group_curly_parentheses_special _expression
    | FUNC_PROD group_curly_parentheses_special _expression

superscript: _expression_func CARET (_expression_power | CMD_PRIME | CMD_ASTERISK)
    | _expression_func CARET L_BRACE (PRIMES | STARS | PRIMES_VIA_CMD | STARS_VIA_CMD) R_BRACE

matrix_prime: (matrix | group_round_parentheses) PRIMES

symbol_prime: (_one_letter_symbol) PRIMES

fraction: _basic_fraction
    | _simple_fraction
    | _general_fraction

_basic_fraction: CMD_FRAC (DIGIT | _one_letter_symbol)~2

_simple_fraction: CMD_FRAC DIGIT expression_func_args
    | CMD_FRAC expression_func_args (DIGIT | _one_letter_symbol)

_general_fraction: CMD_FRAC expression_func_args expression_func_args

binomial: _basic_binomial
    | _simple_binomial
    | _general_binomial

_basic_binomial: CMD_BINOM DIGIT (DIGIT | _one_letter_symbol)

_simple_binomial: CMD_BINOM DIGIT group_curly_parentheses
    | CMD_BINOM group_curly_parentheses (DIGIT | _one_letter_symbol)

_general_binomial: CMD_BINOM group_curly_parentheses group_curly_parentheses

list_of_expressions: _expression ("," _expression)*

function_applied: _one_letter_symbol L_PAREN list_of_expressions R_PAREN

min: FUNC_MIN L_PAREN list_of_expressions R_PAREN

max: FUNC_MAX L_PAREN list_of_expressions R_PAREN

bra: CMD_LANGLE _expression BAR

ket: BAR _expression CMD_RANGLE

inner_product: CMD_LANGLE _expression BAR _expression CMD_RANGLE

_function: function_applied
    | abs | floor | ceil
    | _trigonometric_function | _inverse_trigonometric_function
    | _trigonometric_function_power
    | _hyperbolic_trigonometric_function | _inverse_hyperbolic_trigonometric_function
    | exponential
    | log
    | square_root
    | factorial
    | conjugate
    | max | min
    | bra | ket | inner_product
    | determinant
    | trace
    | adjugate

exponential: FUNC_EXP expression_func_args

log: FUNC_LOG expression_func_args
    | FUNC_LN expression_func_args
    | FUNC_LG expression_func_args
    | FUNC_LOG UNDERSCORE (DIGIT | _one_letter_symbol) expression_func_args
    | FUNC_LOG UNDERSCORE group_curly_parentheses expression_func_args

square_root: FUNC_SQRT expression_func_args
    | FUNC_SQRT group_square_brackets expression_func_args

factorial: expression_func_args BANG

// TODO: what should this be?
conjugate: CMD_OVERLINE group_curly_parentheses
    | CMD_OVERLINE DIGIT

_trigonometric_function: sin | cos | tan | csc | sec | cot

sin: FUNC_SIN expression_func_args
cos: FUNC_COS expression_func_args
tan: FUNC_TAN expression_func_args
csc: FUNC_CSC expression_func_args
sec: FUNC_SEC expression_func_args
cot: FUNC_COT expression_func_args

_trigonometric_function_power: sin_power | cos_power | tan_power | csc_power | sec_power | cot_power

sin_power: FUNC_SIN CARET _expression_core expression_func_args
cos_power: FUNC_COS CARET _expression_core expression_func_args
tan_power: FUNC_TAN CARET _expression_core expression_func_args
csc_power: FUNC_CSC CARET _expression_core expression_func_args
sec_power: FUNC_SEC CARET _expression_core expression_func_args
cot_power: FUNC_COT CARET _expression_core expression_func_args

_hyperbolic_trigonometric_function: sinh | cosh | tanh

sinh: FUNC_SINH expression_func_args
cosh: FUNC_COSH expression_func_args
tanh: FUNC_TANH expression_func_args

_inverse_trigonometric_function: arcsin | arccos | arctan | arccsc | arcsec | arccot

arcsin: FUNC_ARCSIN expression_func_args
arccos: FUNC_ARCCOS expression_func_args
arctan: FUNC_ARCTAN expression_func_args
arccsc: FUNC_ARCCSC expression_func_args
arcsec: FUNC_ARCSEC expression_func_args
arccot: FUNC_ARCCOT expression_func_args

_inverse_hyperbolic_trigonometric_function: asinh | acosh | atanh

asinh: FUNC_ARSINH expression_func_args
acosh: FUNC_ARCOSH expression_func_args
atanh: FUNC_ARTANH expression_func_args

abs: BAR _expression BAR
floor: L_FLOOR _expression R_FLOOR
ceil: L_CEIL _expression R_CEIL

matrix: CMD_MATRIX_BEGIN matrix_body CMD_MATRIX_END
matrix_body: matrix_row (MATRIX_ROW_DELIM matrix_row)* (MATRIX_ROW_DELIM)?
matrix_row: _expression (MATRIX_COL_DELIM _expression)*
determinant: (CMD_DETERMINANT_BEGIN matrix_body CMD_DETERMINANT_END)
    | FUNC_DETERMINANT expression_func_args
trace: FUNC_MATRIX_TRACE expression_func_args
adjugate: FUNC_MATRIX_ADJUGATE expression_func_args

// ================================== NEW STUFF ===========================================

// TODO: investigate if there is a better way to do this, now that we have access to the entire grammar.
// fix implicit multiplication not working in cases after explicit multiplication,
// functions, or matricies.

whitespace: /\s+/

// need to override the whole thing here, as the first part of the rule needed to be modified,
// and fixing it with an extension would lead to an ambigiouity whenever this case was encountered. 
%override adjacent_expressions.1: _expression_power whitespace _expression_mul
    | number _expression_mul
    | group_round_parentheses (group_round_parentheses | _one_letter_symbol)
    | _function _function
    | fraction _expression_mul

%extend mul: _expression_mul MUL_SYMBOL adjacent_expressions
// %extend div: _expression_mul MUL_SYMBOL adjacent_expressions

// add mathematical constants
PI: "\\pi"
EULER: "e"
TAU: "\\tau"
IMAGINARY_CONSTANT: "i" // note: this is already present as CMD_IMAGINARY_UNIT, but it is prioritized way too low, so it is also added as a constant.

MATH_CONSTANTS: PI | EULER | TAU | IMAGINARY_CONSTANT

math_constant.1: MATH_CONSTANTS
%extend _atomic_expr: math_constant 

// add the standard matrix norm function
NORM: "\\Vert" | "\\lVert" | "\\rVert"
matrix_norm: NORM _expression NORM
%extend _function: matrix_norm

INNER_PRODUCT_CENTER: BAR | ","

// add the standard matrix inner product function
matrix_inner_product.1: CMD_LANGLE _expression INNER_PRODUCT_CENTER _expression CMD_RANGLE
%extend _function: matrix_inner_product
// remove the physics inner product...
%override inner_product: /a^/

// add gradient operator
GRADIENT: "\\nabla"
gradient: GRADIENT _expression_func
%extend _function: gradient

// add hessian operator
HESSIAN: "\\mathbf{H}"
hessian: HESSIAN _expression_func
%extend _function: hessian

// add jacobian operator
JACOBIAN: "\\mathbf{J}"
jacobian: JACOBIAN _expression_func
%extend _function: jacobian

// add rref operator
RREF: "\\mathrm{rref}"
rref: RREF _expression_func
%extend _function: rref

// add quick hand notation for differentiating expressions
// e.g. (x^2)' -> 2x
%override matrix_prime: matrix PRIMES
quick_derivative: group_round_parentheses PRIMES
%extend _function: quick_derivative

// ==== multi expression environments ====
ALIGN_ENV: L_BRACE "align" R_BRACE
CASES_ENV: L_BRACE "cases" R_BRACE 

CMD_BEGIN_ALIGN: CMD_BEGIN ALIGN_ENV
CMD_BEGIN_CASES: CMD_BEGIN CASES_ENV
CMD_END_ALIGN: CMD_END ALIGN_ENV
CMD_END_CASES: CMD_END CASES_ENV

system_of_expressions: CMD_BEGIN_ALIGN _system_of_expressions_body CMD_END_ALIGN | CMD_BEGIN_CASES _system_of_expressions_body CMD_END_CASES
// the body should contain any latex parsable string separated by \\ character groups.
_system_of_expressions_body: system_of_expressions_expr (MATRIX_ROW_DELIM system_of_expressions_expr)* (MATRIX_ROW_DELIM)?

system_of_expressions_expr: latex_string

%extend latex_string: system_of_expressions

// TODO: there is probably also a better way to do this now.

// Partial relations, that is relations which are missing a left or right side
// eg. = 5, 25 < and so on...

// enable aligning around relations, its the lesser of two evils,
// as we cannot simply ignore the '&' because they are relevant for matricies,
// but supporting them in all expressions would be too large of a refactor of sympy's grammar file.
align_rel{relation}: MATRIX_COL_DELIM* relation MATRIX_COL_DELIM*
_partial_rel{relation}: align_rel{relation} _expression | _expression align_rel{relation}

partial_relation: _partial_rel{EQUAL} | _partial_rel{NOT_EQUAL} | _partial_rel{LT} | _partial_rel{LTE} | _partial_rel{GT} | _partial_rel{GTE}
%extend latex_string: partial_relation

_complete_rel{relation}: _expression align_rel{relation} _expression

%override eq: _complete_rel{EQUAL}
%override ne: _complete_rel{NOT_EQUAL}
%override lt: _complete_rel{LT}
%override lte: _complete_rel{LTE}
%override gt: _complete_rel{GT}
%override gte: _complete_rel{GTE}

// chained relations
// that is eg. a = b = c, or a < b < c and so on...
_chained_relation{relation}: (_relation | chained_relation | partial_relation) relation _expression
chained_relation: _chained_relation{EQUAL} | _chained_relation{NOT_EQUAL} | _chained_relation{LT} | _chained_relation{LTE} | _chained_relation{GT} | _chained_relation{GTE}

%extend latex_string: chained_relation
